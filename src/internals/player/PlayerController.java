package internals.player;

import java.io.*;
import java.util.HashMap;


/**
 * Η κλάση {@code PlayerController}, αποτελεί κλάση τύπου "controller" για την κλάση {@code Player}.
 * Δηλαδή, αποθηκεύει και χειρίζεται αντικείμενα τύπου {@code Player} και προσφέρει ένα απλό περιβάλλον διαχείρισης αυτών μέσω κλήσης μεθόδων.
 *
 * @author Ioannis Baraklilis
 * @author Alexandros Tsingos
 *
 * @version 2020.12.31
 */
public class PlayerController {
    private HashMap<String, Player> playerStore; // Αποθηκεύει τους παίχτες, δίνοντας την δυνατότητα να αντιστοιχίσουμε εύκολα τα ονόματα τους με το αντίστοιχο αντικείμενο που τούς διαχειρίζεται.

    /**
     * Τυπικός κατασκευαστής της κλάσης. Αρχικοποιεί τα δεδομένα της κλάσης.
     */
    public PlayerController() {
        this.playerStore = new HashMap<>();
    }

    /**
     * Δημιουργεί έναν παίχτη και επιστρέφει την κατάσταση επιτυχίας αυτής της ενέργειας.
     *
     * Άν δεν υπάρχει ίδιος παίχτης με το ίδιο όνομα, η ενέργεια θα πετύχει και θα επιστραφεί η συμβολοσειρά "Επιτυχία".
     * Διαφορετικά, η ενέργεια δεν θα πετύχει και θα επιστραφεί συμβολοσειρά που περιγράφει το σφάλμα.
     *
     * @param playerName όνομα νέου παίχτη.
     * @return κατάσταση επιτυχίας της μεθόδου. "Επιτυχία" σε περίπτωση επιτυχίας, "Υπάρχει ήδη παίχτης με αυτό το όνομα" διαφορετικά.
     */
    public String createPlayer(String playerName){
        if (playerStore.containsKey(playerName)){ // Αν υπάρχει ήδη παίχτης με ίδιο όνομα
            return "Υπάρχει ήδη παίχτης με αυτό το όνομα";
        } else {
            playerStore.put(playerName, new Player(playerName)); // Δημιουργώ και αποθηκεύω νέο παίχτη
            return "Επιτυχία";
        }
    }

    /**
     * Διαγράφει έναν παίχτη και επιστρέφει την κατάσταση επιτυχίας αυτής της ενέργειας.
     *
     * Άν υπάρχει παίχτης με αυτό το όνομα, η ενέργεια θα πετύχει και θα επιστραφεί η συμβολοσειρά "Επιτυχία".
     * Διαφορετικά, η ενέργεια θα δεν πετύχει και θα επιστραφεί συμβολοσειρά που περιγράφει το σφάλμα.
     *
     * @param playerName το όνομα του παίχτη προς διαγραφή.
     * @return η κατάσταση επιτυχίας της μεθόδου. "Επιτυχία" σε περίπτωση επιτυχίας, "Δεν υπάρχει παίχτης με αυτό το όνομα" διαφορετικά.
     */
    public String removePlayer(String playerName){
        Player temp = playerStore.remove(playerName); // Διαγράφω απο το HashMap το αντικείμενο που αντιστοιχεί στην συμβολοσειρά ορίσματος και παίρνω αναφορά στο αντικείμενο αυτό
        if (temp != null){ // Άν το παραπάνω αντικείμενο δεν είναι το null, τότε ο παίχτης υπάρχει και τον διέγραψα απο την δομή
            return "Επιτυχία";
        } else { // Ο παίχτης δεν υπάρχει και δεν τον διέγραψα από την δομή
            return "Δεν υπάρχει παίχτης με αυτό το όνομα";
        }
    }

    /**
     * Αλλάζει το όνομα ενός παίχτη και επιστρέφει την κατάσταση επιτυχίας αυτής της ενέργειας.
     *
     * Άν υπάρχει παίχτης με αυτό το όνομα και δεν υπάρχει παίχτης με ίδιο όνομα με το νέο που δίνεται σαν δεύτερο όρισμα, η ενέργεια θα πετύχει.
     * Διαφορετικά, η ενέργεια θα δεν πετύχει και θα επιστραφεί συμβολοσειρά που περιγράφει το σφάλμα.
     *
     * Επιστρέφει: "Επιτυχία" σε περίπτωση επιτυχίας,
     * διαφορετικά επιστρέφει "Δεν υπάρχει παίχτης με το όνομα: " + playerName + "! Δεν μπορεί να γίνει αλλαγή όνομα παίχτη που δεν υπάρχει..." ή
     * "Υπάρχει ήδη παίχτης με το όνομα: " + newName + "! Δεν μπορούν να υπάρχουν δύο παίχτες με το ίδιο όνομα...", αντιστοίχως με το πρόβλημα.
     *
     * @param playerName όνομα παίχτη προς αλλαγή.
     * @param newName νέο όνομα παίχτη προς αλλαγή.
     * @return κατάσταση επιτυχίας μεθόδου.
     */
    public String changePlayerName(String playerName, String newName){
        Player p = playerStore.get(playerName); // Παίρνω αναφορά στο αντικείμενο που αντιστοιχεί στο πρώτο όρισμα

        if (p == null){ // Επιστράφηκε null, το αντικείμενο δεν υπάρχει!
            return "Δεν υπάρχει παίχτης με το όνομα: " + playerName + "! Δεν μπορεί να γίνει αλλαγή όνομα παίχτη που δεν υπάρχει...";
        } else if (!playerExists(newName).equals("Επιτυχία")){ // Άν δεν υπάρχει αποθηκευμένος παίχτης με το νέο όνομα (δεύτερο όρισμα)
            playerStore.remove(playerName); // Αφαιρώ την παλιά εγγραφή παίχτη
            p.setName(newName); // Αλλάζω το όνομα
            playerStore.put(newName, p); // Εισάγω εκ νέου τον παίχτη στην δομή
            return "Επιτυχία";
        } else { // Υπάρχει αποθηκευμένος παίχτης με το νέο όνομα (δεύτερο όρισμα)
            return "Υπάρχει ήδη παίχτης με το όνομα: " + newName + "! Δεν μπορούν να υπάρχουν δύο παίχτες με το ίδιο όνομα...";
        }
    }

    /**
     * Επιστρέφει δισδιάστατο πίνακα συμβολοσειρών που αναπαριστούν τον πίνακα με τα σκορ όλων των αποθηκευμένων παιχτών.
     *
     * Συγκεκριμένα, αυτός ο δισδιάστατος πίνακας θα έχει αριθμό γραμμών ίσο με το πλήθος των παιχτών
     * και αριθμό στηλών ίσο με τέσσερα: Η πρώτη στήλη ({@code getScoreboard()[i][0]}) περιέχει το όνομα του (i-ου) παίχτη,
     * η δεύτερη στήλη ({@code getScoreboard()[i][1]}) το τρέχον σκορ του (i-ου) παίχτη,
     * η τρίτη στήλη ({@code getScoreboard()[i][2]}) το μέγιστο σκορ (highScore) του (i-ου) παίχτη στο ατομικό παιχνίδι
     * και η τέταρτη στήλη ({@code getScoreboard()[i][3]}) τον αριθμό των νικών σε παιχνίδι πολλών παιχτών του (i-ου) παίχτη.
     *
     * @return Δισδιάστατος πίνακας που αναπαριστά τον πίνακα με τα σκορ και highScore όλων των αποθηκευμένων παιχτών.
     */
    public String[][] getScoreboard(){
        String[][] temp = new String[playerStore.size()][4];

        int i = 0;
        for (Player p : playerStore.values()){
            temp[i][0] = p.getName();
            temp[i][1] = Integer.toString(p.getScore());
            temp[i][2] = Integer.toString(p.getHighScore());
            temp[i][3] = Integer.toString(p.getMultiplayerWins());
            i++;
        }

        return temp;
    }

    /**
     * Επιστρέφει το τρέχον σκορ του παίχτη (αν αυτός υπάρχει) με το όνομα που δίνεται ως όρισμα.
     * Άν δεν υπάρχει ο παίχτης επιστρέφεται -1.
     *
     * Επισήμανση: Το -1 δεν υπάρχει περίπτωση να αποτελέσει δυνατή τιμή του τρέχοντος σκορ του παίχτη.
     *
     * @param playerName όνομα παίχτη του οποίου το σκορ θα επιστραφεί.
     * @return το σκορ του παίχτη αν αυτός υπάρχει, διαφορετικά -1.
     */
    public int getPlayerScore(String playerName){
        Player p = playerStore.get(playerName); // Παίρνω αναφορά στο αντικείμενο που αντιστοιχεί στο όρισμα

        if (p == null){ // Δεν υπάρχει ο παίχτης αφού επιστράφηκε null
            return -1;
        }
        else {
            return p.getScore();
        }
    }

    /**
     * Υπολογίζει και αποθηκεύει το νέο σκορ του παίχτη (αν αυτός υπάρχει) του οποίου το όνομα δίνεται ως όρισμα και επιστρέφεται η κατάσταση επιτυχίας αυτής της ενέργειας.
     * Αν υπάρχει παίχτης με αυτό το όνομα, η ενέργεια επιτυγχάνει και επιστρέφεται true, διαφορετικά επιστρέφεται false.
     * Άν το νέο σκορ είναι μεγαλύτερο απο το παλιό, το νέο τίθεται ως το μέγιστο σκορ παίχτη.
     *
     * @param playerName όνομα του παίχτη.
     * @param gain πόντοι που θα προστεθούν στο τρέχον σύνολο πόντων (μπορεί να είναι και αρνητικό).
     * @return η κατάσταση επιτυχίας της μεθόδου.
     */
    public boolean playerCalculateGain(String playerName, int gain){
        Player p = playerStore.get(playerName); // Παίρνω αναφορά στο αντικείμενο που αντιστοιχεί στο πρώτο όρισμα

        if (p == null){ // Δεν υπάρχει ο παίχτης αφού επιστράφηκε null
            return false;
        }
        else{ // Υπολογίζεται και αποθηκεύεται το νέο σκορ του παίχτη
            p.scoreGain(gain);
            return true;
        }


    }

    /**
     * Επιστρέφει το μέγιστο σκορ (highScore) του παίχτη (αν αυτός υπάρχει) του οποίου το όνομα δίνεται ως όρισμα.
     * Αν υπάρχει παίχτης με αυτό το όνομα, η ενέργεια επιτυγχάνει και επιστρέφεται το μέγιστο σκορ, διαφορετικά επιστρέφεται -1.
     *
     * Επισήμανση: Το -1 δεν υπάρχει περίπτωση να αποτελέσει δυνατή τιμή του HighScore του παίχτη.
     *
     * @param playerName όνομα του παίχτη.
     * @return το μέγιστο σκορ (highScore) του παίχτη αν αυτός υπάρχει, διαφορετικά -1.
     */
    public int getPlayerHighScore(String playerName){
        Player p = playerStore.get(playerName); // Παίρνω αναφορά στο αντικείμενο που αντιστοιχεί στο όρισμα

        if (p == null){ // Δεν υπάρχει ο παίχτης αφού επιστράφηκε null
            return -1;
        }

        return p.getHighScore(); // Επιστρέφεται το μέγιστο σκορ
    }


    /**
     * Επιστρέφει ένα πίνακα συμβολοσειρών ο οποίος περιέχει τα ονόματα των αποθηκευμένων παιχτών.
     *
     * @return πίνακα συμβολοσειρών με τα ονόματα των παιχτών.
     */
    public String[] listPlayers(){
        String[] playerNames = new String[playerStore.size()];
        int i=0;
        for(String aPlayerName : playerStore.keySet()){ // Εισάγω ένα-ένα τα ονόματα των παιχτών στον πίνακα
            playerNames[i] = aPlayerName;
            i++;
        }

        return playerNames;
    }


    /**
     * Ελέγχει εάν ο παίχτης του οποίου το όνομα δίνεται ως όρισμα υπάρχει στο παιχνίδι και επιστρέφει την κατάσταση επιτυχίας αυτής της ενέργειας.
     *
     * Αν το όνομα που δόθηκε ως όρισμα αντιστοιχεί σε κάποιον παίχτη επιστρέφει τη συμβολοσειρά "επιτυχία" .
     *
     *  Διαφορετικά επιστρέφεται η συμβολοσειρά: "Δεν υπάρχει παίχτης με το συγκεκριμένο όνομα"
     * @param playerName όνομα του παίχτη.
     * @return η κατάσταση επιτυχίας της μεθόδου. "Επιτυχία" σε περίπτωση επιτυχίας, "Δεν υπάρχει παίχτης με το συγκεκριμένο όνομα" διαφορετικά.
     */
    public String playerExists(String playerName){
        if (playerStore.containsKey(playerName)){ // Υπάρχει
            return "Επιτυχία";
        }
        else{ // Δεν υπάρχει
            return "Δεν υπάρχει παίχτης με το συγκεκριμένο όνομα";
        }
    }

    /**
     * Επιστρέφει τον αριθμό των παιχτών του παιχνιδιού.
     *
     * @return ο αριθμός των παιχτών.
     */
    public int getNumberOfPlayers(){
        return playerStore.size();
    }

    /**
     * Μηδενίζει το τρέχον σκορ του παίχτη του οποίου το όνομα δίνεται ως όρισμα.
     * @param playerName όνομα του παίχτη.
     * @return η κατάσταση επιτυχίας της μεθόδου. "Επιτυχία" σε περίπτωση επιτυχίας, "Δεν υπάρχει παίχτης με το συγκεκριμένο όνομα" διαφορετικά.
     */
    public String clearPlayerScore(String playerName){
        if (playerStore.containsKey(playerName)){ // Ο παίχτης υπάρχει
            playerStore.get(playerName).clearCurrentScore();
            return "Επιτυχία";
        }
        else{ // Δεν υπάρχει
            return "Δεν υπάρχει παίχτης με το συγκεκριμένο όνομα";
        }
    }

    /**
     * Μηδενίζει το τρέχον σκορ κάθε παίχτη
     */
    public void clearAllPlayersScore(){
        for (Player p : playerStore.values()){
            p.clearCurrentScore();
        }
    }

    /**
     * Επιστρέφει τον αριθμό των νικών του παίχτη (αν αυτός υπάρχει) σε παιχνίδι πολλών παιχτών του οποίου το όνομα δίνεται ως όρισμα.
     * Αν υπάρχει παίχτης με αυτό το όνομα, η ενέργεια επιτυγχάνει και επιστρέφεται ο αριθμός των νικών του παίχτη, διαφορετικά επιστρέφεται -1.
     *
     * @param playerName όνομα του παίχτη.
     * @return αριθμός νικών σε παιχνίδι πολλών παιχτών του παίχτη αν αυτός υπάρχει, διαφορετικά -1.
     */
    public int getMultiplayerWins(String playerName){
        if (playerStore.containsKey(playerName)){ // Ο παίχτης υπάρχει
            Player p = playerStore.get(playerName);
            return p.getMultiplayerWins();
        }
        else{ // Δεν υπάρχει
            return -1;
        }
    }

    /**
     * Αυξάνει τον αριθμό των νικών του παίχτη (αν αυτός υπάρχει) σε παιχνίδι πολλών παιχτών κατά 1 και επιστρέφει τον νέο αριθμό.
     * Αν υπάρχει παίχτης με αυτό το όνομα, η ενέργεια επιτυγχάνει και επιστρέφεται ο αριθμός των νικών του παίχτη, διαφορετικά επιστρέφεται -1.
     *
     * @param playerName όνομα του παίχτη.
     * @return αριθμός νικών σε παιχνίδι πολλών παιχτών του παίχτη αν αυτός υπάρχει, διαφορετικά -1.
     */
    public int countMultiplayerWins(String playerName){
        if (playerStore.containsKey(playerName)){ // Ο παίχτης υπάρχει
            Player p = playerStore.get(playerName);
            p.countMultiplayerWin();
            return p.getMultiplayerWins();
        }
        else{ // Δεν υπάρχει ο παίχτης
            return -1;
        }
    }


    /**
     * Για κάθε παίχτη, αποθηκεύει σε δυαδικό αρχείο το όνομα του, τις νίκες του σε παιχνίδι 2 παιχτών,
     * καθώς και το υψηλότερο του σκορ στο ατομικό παιχνίδι.
     * @param fileName Το όνομα του αρχείου στο οποίο θα αποθηκευτούν τα στατιστικά του παιχνιδιού.
     * @throws IOException Σε περίπτωση που εμφανιστεί πρόβλημα κατά την αποθήκευση των στατιστικών σε δυαδικό αρχείο ή υπάρχει πρόβλημα με το serialization.
     */
    public void saveGameStatistics(String fileName) throws IOException{

        try(ObjectOutputStream out = new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(fileName)))){
            out.writeObject(playerStore);
        }
    }

    /**
     * Φορτώνει στην μνήμη τα στατιστικά των παιχτών, δηλαδή όνομα,High Score και τον αριθμό των νικών του σε παιχνίδι πολλών παιχτών,
     * από προηγούμενα παιχνίδια.
     * @param fileName Το όνομα του αρχείου από το οποίο θα φορτωθούν τα στατιστικά από προηγούμενα παιχνίδια.
     * @throws IOException Σε περίπτωση που υπάρχει πρόβλημα κατά το άνοιγμα και το διάβασμα του αρχείου.
     * @throws ClassNotFoundException Σε περίπτωση που δεν μπορεί να βρεθεί κλάση Serialized αντικειμένου.
     */
    public void loadGameStatistics(String fileName) throws IOException,ClassNotFoundException{

        try(ObjectInputStream in = new ObjectInputStream(new BufferedInputStream(new FileInputStream(fileName)))){
            clearAllPlayersScore();
            playerStore = (HashMap<String, Player>) in.readObject();
        }
    }


}
